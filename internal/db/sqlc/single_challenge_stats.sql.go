// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: single_challenge_stats.sql

package db

import (
	"context"
)

const getSingleStatsByChallengeID = `-- name: GetSingleStatsByChallengeID :many
SELECT user_id, challenge_id, created_at, time_taken, wpm, accuracy
FROM single_challenge_stats
WHERE challenge_id = $1
`

func (q *Queries) GetSingleStatsByChallengeID(ctx context.Context, challengeID int32) ([]SingleChallengeStat, error) {
	rows, err := q.db.Query(ctx, getSingleStatsByChallengeID, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SingleChallengeStat
	for rows.Next() {
		var i SingleChallengeStat
		if err := rows.Scan(
			&i.UserID,
			&i.ChallengeID,
			&i.CreatedAt,
			&i.TimeTaken,
			&i.Wpm,
			&i.Accuracy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleStatsByUserID = `-- name: GetSingleStatsByUserID :many
SELECT user_id, challenge_id, created_at, time_taken, wpm, accuracy
FROM single_challenge_stats
WHERE user_id = $1
`

func (q *Queries) GetSingleStatsByUserID(ctx context.Context, userID int32) ([]SingleChallengeStat, error) {
	rows, err := q.db.Query(ctx, getSingleStatsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SingleChallengeStat
	for rows.Next() {
		var i SingleChallengeStat
		if err := rows.Scan(
			&i.UserID,
			&i.ChallengeID,
			&i.CreatedAt,
			&i.TimeTaken,
			&i.Wpm,
			&i.Accuracy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleStatsByUserIDAndChallengeID = `-- name: GetSingleStatsByUserIDAndChallengeID :one
SELECT user_id, challenge_id, created_at, time_taken, wpm, accuracy
FROM single_challenge_stats
WHERE user_id = $1
  AND challenge_id = $2
`

type GetSingleStatsByUserIDAndChallengeIDParams struct {
	UserID      int32 `json:"user_id"`
	ChallengeID int32 `json:"challenge_id"`
}

func (q *Queries) GetSingleStatsByUserIDAndChallengeID(ctx context.Context, arg GetSingleStatsByUserIDAndChallengeIDParams) (SingleChallengeStat, error) {
	row := q.db.QueryRow(ctx, getSingleStatsByUserIDAndChallengeID, arg.UserID, arg.ChallengeID)
	var i SingleChallengeStat
	err := row.Scan(
		&i.UserID,
		&i.ChallengeID,
		&i.CreatedAt,
		&i.TimeTaken,
		&i.Wpm,
		&i.Accuracy,
	)
	return i, err
}
